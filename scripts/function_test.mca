; calls a given function (header/line index and page index/name)
!macro call function_arg page_arg
    LdiR 5  ; loading 5 to the right alu register, to add to the line number (5 instructions are added after this
    PgcL    ; the left register contains the current line
    Add     ; adding the two together
    PshO    ; pushing the result onto the stack
    PshCon page_arg  ; pushing the current page onto the stack
    Goto function_arg page_arg   ; this should actually jump to the function
    ; it should jump to here upon exit (i.e. the next line, which is outside this macro)
!end

; returns from a function, assuming the return address is on the top of the stack
!macro ret
    TopL      ; load the left alu register with the top of the stack
    Pop       ; removing the top element (TopL doesn't pop, and pop doesn't return a value, so both are needed)
    ThruL     ; loading the return page into alu_out to get it into a register
    WrtO rda  ; writing the output to rda to use for setting the page
    SetPageReg rda   ; setting the page register to the return page
    ; repeating, but for the line number
    TopL      ; load the left alu register with the top of the stack
    Pop       ; removing the top element (TopL doesn't pop, and pop doesn't return a value, so both are needed)
    ThruL     ; loading the return address into alu_out to get it into a register
    WrtO rda  ; writing the output to rda to use for jumping
    JmpR rda  ; returning/jumping to the callers address
!end

; jumping to the program's start
Jmp Start

; a random function ig
!header TestFunction
    ; A simple test function that adds two numbers and recurses until overflow
    Ldi rda 10   ; another random numbers for testing
    LodL rda     ; loading the alu inputs
    LodR rdc     ; loading the alu inputs (rdc was set outside the function)
    Add          ; adding the two numbers
    WrtO rdc     ; writing the output to rdc, to store the result
    LodL rdc     ; as rdc grows, it'll eventually overflow when added to 200
    LdiR 200     ; 200 is a large number so it'll overflow quickly
    Add          ; adding them to set the overflow flag
    OvrFlow      ; setting the condition flag
    Jiz TestFuncEnd  ; jumping to the end if overflow occurred (to stop infinite recursion)
    call TestFunction main  ; recursively calling itself to test stack behavior
!end TestFuncEnd
    ret          ; returning to the caller

!header Start
    Ldi rdc 20   ; a random number for testing
    ; calling the macro to test the function call
    call TestFunction main  ; this is an example where the first page index (0) is used with its alias of "main"
    PshCon 2     ; to make sure it's correctly jumping to the next line upon return
    Kill
